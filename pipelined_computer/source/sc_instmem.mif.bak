DEPTH = 64;           % Memory depth and width are required %
WIDTH = 32;           % Enter a decimal number %
ADDRESS_RADIX = HEX;  % Address and value radixes are optional %
DATA_RADIX = HEX;     % Enter BIN, DEC, HEX, or OCT; unless %
                      % otherwise specified, radixes = HEX %
CONTENT
BEGIN
0 : 3c010000;  % main:	 lui $1, 0 		# address of data[0] | 00111100000000010000000000000000 %
1 : 34240050;  % 	ori $4, $1, 80   	# address of data[0] % | 00110100001001000000000001010000 %
2 : 20050004;  % 	addi $5, $0, 4 	# counter% | 00100000000001010000000000000100 %
3 : 0c000018;  % call:	 jal sum 	# call function % | 00001100000000000000000000011000 %
4 : ac820000;  % 	sw $2, 0($4) 	# store result % | 10101100100000100000000000000000 %
5 : 8c890000;  % 	lw $9, 0($4) 	# check sw % | 10001100100010010000000000000000 %
6 : 01244022;  % 	sub $8, $9, $4 	# sub: $8 < $9 -$4% | 00000001001001000100000000100010 %
7 : 20050003;  % 	addi $5, $0, 3 	# counter % | 00100000000001010000000000000011 %
8 : 20a5ffff;  % loop2: 	addi $5, $5,-1 	# counter -1 % | 00100000101001011111111111111111 %
9 : 34a8ffff;  % 	ori $8, $5, 0xffff 	# zero extend: 0000ffff % | 00110100101010001111111111111111 %
a : 3908ffff;  % 	xori $8, $8, 0x5555	 # zero extend: 0000aaaa % | 00111001000010001111111111111111 %
b : 2009ffff;  % 	addi $9, $0, -1 	# sign extend: ffffffff % | 00100000000010011111111111111111 %
c : 312affff;  % 	andi $10, $9, 0xffff	 # zero extend: 0000ffff % | 00110001001010101111111111111111 %
d : 01493025;  % 	or $6, $10, $9 	# or: ffffffff % | 00000001010010010011000000100101 %
e : 01494026;  % 	xor $8, $10, $9 	# xor: ffff0000 | 00000001010010010100000000100110 %
f : 01463824;  % 	and $7, $10, $6 	# and: 0000ffff % | 00000001010001100011100000100100 %
10 : 10a00001;  % 	beq $5, $0, shift 	# if $5 = 0, goto shift | 00010000101000000000000000000001 %
11 : 08000008;  % 	j loop2 		# jump loop2 % | 00001000000000000000000000001000 %
12 : 2005ffff;  % shift: 	addi $5, $0,-1	# $5 = ffffffff % | 00100000000001011111111111111111 %
13 : 000543c0;  % 	sll $8, $5, 15 	# <<15 = ffff8000 % | 00000000000001010100001111000000 %
14 : 00084400;  % 	sll $8, $8, 16 	# <<16 = 80000000 % | 00000000000010000100010000000000 %
15 : 00084403;  % 	sra $8, $8, 16 	 # >>16 = ffff8000 (arith) % | 00000000000010000100010000000011 %
16 : 000843c2;  % 	srl $8, $8, 15 	# >>15 = 0001ffff (logic) % | 00000000000010000100001111000010 %
17 : 08000017;  % finish:	 j finish 		 # dead loop % | 00001000000000000000000000010111 %
18 : 00004020;  % sum: 	add $8, $0, $0 	# sum % | 00000000000000000100000000100000 %
19 : 8c890000;  % loop:	 lw $9, 0($4) 	# load data % | 10001100100010010000000000000000 %
1a : 20840004;  % 	addi $4, $4, 4 	# address + 4 % | 00100000100001000000000000000100 %
1b : 01094020;  % 	add $8, $8, $9 	# sum % | 00000001000010010100000000100000 %
1c : 20a5ffff;  % 	addi $5, $5,-1	# counter - 1 %	 | 00100000101001011111111111111111 %
1d : 14a0fffb;  % 	bne $5, $0, loop 	# finish? % | 00010100101000001111111111111011 %
1e : 00081000;  % 	sll $2, $8, 0 	# move result to $v0 % | 00000000000010000001000000000000 %
1f : 03e00008;  % 	jr $ra 		# return %	 | 00000011111000000000000000001000 %
END ;